适配器模式：
将一个类的接，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

这个模式可以通过创建适配器进行接日转换，让不兼容的接口变成兼容。这可以让客户从实现的接口解解耦，如果在一段时间之后，我们想要改变接
口，适配器可以将改变的部分封装起来。客户就不必为了应对不同的接口而每次跟着修改。

客户使用境说器的过程如下:
1、客户通过目标接口调用适配器的方法对适配器发出请求。
2、适配器使用被适配者接口把请求转换成被适配者的一个或多个调用接口。
3、客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用。


1、实现一个适配器所需要进行的工柞，和目标接口的大小成正比，如果不用适配器，你就必须改写客户端的代码来调用这个祈的接口，将会花许多力气来做大量的调查工作和代码改写工作。
相比之下，提供一个适配器类，将所有的改变封装在一个类中，是比较好的做法。
适配器模式的工作是将一个接口转换成另一个。虽然大多数的适配器摸式所采取的例子都是让一个适配器包装一个被适配者，但我们都知道这个世界其实复杂多了，所以你可能遇到一些状况，
需要让一个适配器包装多个被适配者。这就及另一个摸式，彼称为外观模式(Facacde Pattera}

外观模式：
提供了一个统一的接口，用来访问子系统中外观定义了一个高层接口，让子系统更容易使用。

想要使用外观模式，我们创建一个接口简化而统一的类，用来包装子系统中一个或多个复杂的类。外观模式相当直接，很容易理解，这方面和许多其他的模式不太一样。但这并不会降低
它的威力:外观模式允许我们让客户和子系统之间避免紧耦合。

外观的意图是要提供一个简单的接口，好让一个子系统更易于使用。

外观没有封装子系统的类，只提供简化的接口。所以客户如果觉得有必要，依然可以直接使用子系统的类。这是外砚模式一个很好的特征:提供简化的接口的同时，依然将系统完整的功
能暴露出来，以供需要的人使用。

外观不只是简化了接口，也将客户从组件的子系统中解藕。
外观和适配器可以包装许多类，但是外观的意图是简化接口，而适犯器的意图是将接口转换成不同接口。



“最少知识”原则：
最少知识原则告诉我们要减少对象之间的交互，最少知识原则:只和你的密友谈话。

这到底是什么意思?这是说，当你正在设计一个系统，不管是任何对象，你都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。
这个原则希望我们在设计中，不要让太多的类聚合在一起，免得修改系统中一部分，会影响到其他部分。如果许多类之间相互依赖，那么这个系统就会变成一个易碎的系统，它需要花
许多成本维护，也会因为大复杂而不容易被其他人了解。

究竟要怎样才能避免这样呢?这个原则提供了一些方针:
就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法:
1、该对象本身
2、被当做方法的参数而传递进来的对象
3、此方法所创建或实例化的任何对象
4、对象的任何组件


1、当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器。
2、当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。
3、适配器改变接口以符合客户的期望。
4、外观将客户从一个复杂的子系统中解耦。
5、实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定。
6、实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。
7、你可以为一个子系统实现一个以上的外观。
8、适配器将一个对象包装起来以改变其接口;装饰者将一个对象包装起来以增加新的行为和责任。而外观将一群对象“包装“起来以简化其接口。
