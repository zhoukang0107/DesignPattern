迭代器模式:
提供一种方法顺序访向一个聚合对象中的各个元素。而又不暴露其内部的表示。

迭代器模式把在元素之间游走的责任交给迭代器，而不是聚合对象。这不仅让聚合的接日和实现变得更简洁，也可以让聚合更专注在它所应该专注的事情上面(也就是管理对象集合)。而不必去理会遍历的事情。
送代器模式让我们能游走干聚合内的每一个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚含上。这样简化了聚合的接口和实现，也让责任各得其所。

java迭代器接口：
public interface Iterator<E>{
    boolean hasNext();
    E next();
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
}
注意：
如果我不想让客户具备某些能力，比如remove方法，可以让该方法直接抛出一个java,lang,UnsupportedOperatianException运行时异常。
Iterator的API文件提到可以让remove抛出这样的异常，而任何良好的客户程序只要调用了remove()方法，就应该检查足否会发生这个异常。


设计原则：
一个类应该只有一个引起变化的原因
类的每个责任都有改变的潜在区域。超过一个责任，意味着超过一个改变的区域。这个原则告诉我们，尽量让每个类保持单一责任。
我们知道要避免类内的改变，因为修改代码很容易造成许多潜在的错误。如果有一个类终有两个改变原因。那么这会使得将来该类的变化机率上升，而与它真的
改变时、你的设技中同时有两个方面将会受到影响。


组合模式：
允许你将对象组合成树形结构来表现“整体部分’层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
组含模式让我们能用树形方式创建对象的结构，树里面包含了组含和个别的对象。使用组含结构.我们能把相同的操作应用在组合和个别对象上。换句话说，
在大多数情况下，我们可以忽略对象组含和个别对象之问的差别。

1、迭代器允许访问聚合的元素，而不需要暴露它的内部结构。
2、迭代器将遍历聚合的工作封装进一个对象中。
3、当使用迭代器的时候，我们依赖聚合提供遍历。
4、迭代器提供一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制。
5、我们应该努力让一个类只分配一个责任。
6、组合模式提供一个结构，可同时包容个别对象和组合对象。
7、组合模式允许客户对个别对象以及组合对象一视同仁。
8、组合结构内的任意对象称为组件，组件可以是组合，也可以是叶节点。
9、在实现组合模式时，有许多设计上的折衷。你要根据需要平衡透明性和安全性。
































