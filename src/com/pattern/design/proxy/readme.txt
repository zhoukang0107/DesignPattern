代理模式:
为另一个对象提供一个替身或占位符以控制对这个对象的访问。
使用代理模式创建代表(representative)对象.让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。

代理模式有许多变体，而这些变体几乎都和“控制访问”的做法有关。

远程代理：RMI、AIDL
远程代理可以作为另一个JvM上对像的本地代表。调用代理的方法，会被代理利用网络转发到远程执行，井且结果会通过网络返回给代理，再由代理将结果转给客户。

虚拟代理：
虚拟代理作为创建开销大的对象的代表。虑拟代理经常直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。


在真实的世界中代理模式有许多变体，这些变体都有共通点:都会将客户时主题(subject)施加的方法调用拦截下来。这种间接的级别让我们可以做许多事，
包括将请求分发到远程主题;给创建开梢大的对象提供代表;或者正如你将要看到的.提供某些级别的保护，这种保护能决定哪些客户能调用哪些方法。这还只
是个开端，其实一般的代理模式还可以以许多形式使用。

代理模式和装饰模式：
有时候选两者的确看起来很像，但走它们的目的是不一样的。装饰者为对象增加行为，而代理是控制对象的访问。

如何让容户使用代理，而不是真正的对象?
一个常用的技巧是提供一个工厂，实例化并返回主题。固为这是在工厂方法内发生的。我们可以用代理包装主题再返回，而客户不知道也不在乎他使用的是代理还是真东西。

动态代理：
java在java.lang.reflect包中有自己的代理支持，利用这个包你可以在运行时动态地创建一个代理类，实现一个或多个接口，并将方法的调用转发到你所指
定的类。因为实际的代理类是在运行时创建的，我们称这个Java技术为:动态代理。

代理模式为另一个对象提供代表，以使拎制客户对对象的访间，管理访问的方式有许多种。
远程代理管理客户和远程对象之间的交互。
虚拟代理控制访问实例化开销大的对象。
保护代理基于调用者控制对对象方法的访问。
代理模式有许多变体，例如:缓存代理、同步代理、防火墙代理和写入时复制代理。
代理在结构上类似装饰者，但是目的不同。
装饰者模式为对象加上行为，而代理则是控制访问。
java内置的代理支持，可以根据需要建.立动态代理，并将所有调用分配到所选的处理器。
就和其他的包装者(wrapper)一样，代理会造成你的设计中类的数目增加。










