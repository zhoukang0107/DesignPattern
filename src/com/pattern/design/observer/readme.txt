观察者模式：定义了对象之间一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会收到通知并自动更新；
主题（被观察者）是具有状态的对象，并且可以控制这些状态，也就是说有“一个”具有状态的主题。观察者使用这些状态，虽然这些状态并不属于他们，有许多的观察者，依赖主题来告诉他们状态何时改变了，这就产生了“一个”主题对“多个”观察者的关系；
观察者模式提供了一种对象设计，让主题和观察者之间松耦合；

在此模式中你可以从被观察者处“推”或“拉”数据（推的方式被认为更正确）
观察者收到通知后获取数据的方式：“推”、“拉”
推数据：由被观察者通知观察者时将状态数据主动推送给观察者；
拉数据：由被观察者通知观察者时，观察者通过被观察对象提供的getter方法“拉”走自己想要的状态数据；
缺点：观察者可以获取被观察者更多的信息，被观察者暴露给观察者；另外，观察者可能需要多次调用被观察的方法才能获取新增的状态数据；
优点：扩展较好，需要监控新的状态信息，只需要观察者增加相应的getter方法，观察者就可以获取，而“推”数据的方式则需要修改每一个观察者；

观察者模式中有多个观察者时,不可以依赖特定的通知次数：如果我们的代码依赖这样的次序，一旦观察者/可观察者有所改变，通知次序就会改变，很可能会产生错误的结果；

Java内置观察者模式：
被观察者Observable是一个类，由于java类不支持多继承，当被观察需要继承其他类时，就会陷入两难，这限制了Observable的复用能力；另外由于Observable将setChanged等关键方法保护起来，这就导致了只能继承自Observable,负责无法创建Observable，
并组合到你自己的对象当中来；