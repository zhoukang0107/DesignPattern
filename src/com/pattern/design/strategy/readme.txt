
/**
 * 设计模式模式代码，而是针对设计问题的通用解决方案。大多数的模式和原则都着眼与软件《变化》的主题，大多数模式都允许系统局部的改变独立于其他部分，我们常把系统变化的部分抽取出来封装，模式是你和其他开发人员之间的共享词汇，能够最大化沟通价值，当你用模式描述时，其他开发人员便很容易的知道你对设计的想法，
 * 在软件生命周期中，我们总是花费更多的时间在系统的维护和变化上，这比原先开发花的时间更多；我们应该致力于提高系统的可维护性和可扩展性，建立弹性的设计；大多数的模式和原则都着眼与软件变化的主题
 * 通常在设计系统时，需要预先考虑到未来哪些地方可能需要变化，于是提前在代码中加入弹性；
 * 不管当初软件设计的多好，一段时间后，总是需要成长与改变，否则软件就会死亡。变化是软件开发中不变的整理。
 *
 * version 1
 * 鸭子游戏：SimUDuck
 * 游戏中会出现各种鸭子，一边游泳戏水，一边呱呱叫；
 *
 * version1设计：
 * 由于所有鸭子，都有着一样的叫声，一样的游泳方式，唯独不同的是每个鸭子的外形；
 * 系统设计了一个鸭子超类（Duck），由该超类实现鸭子的“呱呱叫”(quack)和游泳(swim)，因为每个鸭子的外观(display)不同，所以鸭子超类中，外观方法是抽象方法，交由具体的鸭子去实现；这样每个鸭子只需要继承鸭子超类，实现自己特有显示方法即可；
 * 如果有新的外观的鸭子也可以直接继承鸭子超类，实现自己的特有外观即可；
 *
 * version 2
 * 需求变化：随着业务的发展，鸭子游戏不再满足单纯颜色不同的鸭子，更加特异的鸭子需求纷至沓来————会飞的鸭子
 *
 * 方案1：在鸭子超类上加上飞行的本领（flay），然后让所有鸭子都会继承父类的飞行本领；
 * 问题：并非所有的鸭子都会飞，在超类添加飞行本领，出现了会飞的“橡皮鸭子”，对代码局部的修改，影响层面可能不止局部；
 * 解决橡皮鸭子：覆盖掉橡皮鸭子的飞行能力（flay）
 * 新的问题产生：木头鸭子的出现————一种既不会飞（flay）,又不会叫（quack）的鸭子
 * 出现的问题：代码在多个子类中重复;很难知道鸭子的所有行为；改变会前已发动全身，造成其他鸭子的不正常行为；
 *
 * 方案2：根据目前情况可知未来还会有其他鸭子的产生，可能会有不同的飞行能力和叫声，这将成为设计的噩梦；利用接口：将飞行行为(fly)和叫喊声（quack）从超类(Duck)中抽出到单独的接口中（Flyable和Quackable）,只有让会飞或会叫的鸭子继承这些接口
 * 问题：重复的代码更多了，维护成本变高了；所有具有相同飞行能力的鸭子都要重复实现，所有具有相同叫唤的鸭子都需要重复实现；另外，如果需求变更，要求所有“呱呱叫”的鸭子，变成“呱呱呱叫”，那就需要一个一个的类修改~
 * 这是从一个噩梦进入另一个噩梦；
 *
 * version 3
 * 鸭子的行为在子类里面不断的改变，让所有子类都有这些行为是不恰当的。
 * 找出应用中可能需要变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起，让不变的代码不受变化的影响，代码变化引起的不经意的后果变少，系统也将会变得更有弹性；
 * 或者说，如果每次新的需求一来，都会使某方面的代码发生变化，那么就可以确定，这部分代码需要被抽出来，和其他稳定的代码有所区分；
 * 把变化的部分取出来并封装起来，以便以后能轻易的改变或扩充此部分，而不影响不需要变化的其他部分。
 * 分开不变和变化的部分：
 * 鸭子超类（Duck）的飞行（fly）和叫唤（quack）会随着鸭子的不同而改变，我们将他们从鸭子超类（Duck）中抽取出来，建立一组新类来代表每个行为；鸭子将自己的行为委托给这些行为类；
 * 鸭子超类（Duck）：不变的部分，抽出了飞行（fly）和叫唤（quack）能力
 * 鸭子行为：飞行行为，叫唤行为
 * 行为的设计：针对接口编程，而不是针对实现编程
 * 利用接口代表每个行为：飞行行为（FlyBehavior）和叫唤行为（QuackBehavior）,每个具体的行为都将实现其中的一个接口，鸭子超类不再负责实现Flyable和Quackable接口，鸭子类将使用行为接口类来实现自己的行为，实际的实现不会被绑死在鸭子子类中；
 *                   这样设计可以让飞行和叫唤的行为为更多的对象复用，因为这些行为和鸭子已经无关了，我们新增一些行为也不会影响既有的行为类以及使用其他行为的鸭子
 * 针对接口编程即针对超类型编程：利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上；或者说变量的声明类型应该是超类型，通常是一个抽象类或者接口，只要是具体实现此超类型的类所产生的对象，都可以给这个变量，声明类时不用理会以后执行时的真正对象类型；
 * 见 com.pattern.design.strategy.version3
 *
 *
 * 策略模式：定义了算法簇，分别封装起来，让他们之前可以互相替换，此模式让算法的变化独立于使用算法的客户；
 * 将鸭子的一组行为看成是一簇算法；
 * 组合与继承：多用组合少用继承
 * 组合（有一个）：每个鸭子都有一个FlyBehavior和QuackBehavior,好将飞行和叫唤的行为委托给他们代为处理。
 * 使用组合建立系统具有很大的弹性，不仅可以将算法簇封装成类，更可以在运行时动态地改变行为，只有组合的行为对象符合正确的接口标准即可。
 *
 *
 *
 *
 */